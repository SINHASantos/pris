{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pris Pris is a domain-specific language for designing slides and other graphics. Pris allows you to write drawing commands in a lightweight programming language tailored for the task, and compile that to PDF . Graphics can be parametrized easily, and instead of copy-pasting, common elements can be extracted into reusable functions. Features Compiles to PDF . Full typographic control. First class graphics that can be inspected and manipulated as values. First class functions. Example The obligatory \u201chello world\u201d: { put t(\"Hello world\") at (0.1w, 0.5h) } This produces a single page, with the text \u201cHello world\u201d in the default sans-serif font. The leftmost point on the text baseline is located at 10% of the canvas width and 50% of the canvas height. Getting started Pris needs to be built from source. See the building chapter of the docs. Then you might want to take a look at the examples . Please note that Pris is alpha-quality software. Expect things to break.","title":"Overview"},{"location":"#pris","text":"Pris is a domain-specific language for designing slides and other graphics. Pris allows you to write drawing commands in a lightweight programming language tailored for the task, and compile that to PDF . Graphics can be parametrized easily, and instead of copy-pasting, common elements can be extracted into reusable functions.","title":"Pris"},{"location":"#features","text":"Compiles to PDF . Full typographic control. First class graphics that can be inspected and manipulated as values. First class functions.","title":"Features"},{"location":"#example","text":"The obligatory \u201chello world\u201d: { put t(\"Hello world\") at (0.1w, 0.5h) } This produces a single page, with the text \u201cHello world\u201d in the default sans-serif font. The leftmost point on the text baseline is located at 10% of the canvas width and 50% of the canvas height.","title":"Example"},{"location":"#getting-started","text":"Pris needs to be built from source. See the building chapter of the docs. Then you might want to take a look at the examples . Please note that Pris is alpha-quality software. Expect things to break.","title":"Getting started"},{"location":"background/","text":"Background Below are some observations that inspired the design of Pris. Observations While a declarative source with a theme (such as html with css, or LaTeX) works great for long documents, it is somewhat inflexible for slides. Good slides need to be designed, and this is much more a manual process than typesetting large blocks of text. If you want to be able to change themes with a single click, then you need to shoehorn slides into a pretty limited format. Separating markup from content is not a good idea for creative slides: markup is an important part of the content. Conclusion : Don\u2019t try to separate semantics from markup. Specifying semantics is a non-goal. Offer full control over markup instead. To design graphics (which is what good slides should be), a graphical editor can be much nicer than a declarative format. Compare Inkscape with LaTeX and TikZ. However, a text-based declarative format has several advantages: it is nicer to work with in source control, and it can easily be scripted. Compare animating a hand-drawn graph in Google Slides with animating a TikZ drawing in LaTeX and Beamer. Manual animation often involves copying the entire thing, after which changing parts becomes difficult. It is possible to build a graphical editor for a text-based format, but these often produce messy output. Conclusion : A declarative text-based input format that is intended to be written by humans is preferred over an opaque format with a graphical editor. Supporting external graphics (svg logos, jpeg photographs, png graphics) is a must. For consistent graphics, having basic drawing capabilities embedded would be useful (like TikZ in LaTex). The possibility to leverage external tools is limited if consistency is a goal. (For instance, even if the same font is used in externally drawn graphics, the graphic must be scaled to make font sizes match.) Care must be taken to keep the scope narrow: TikZ is a huge project in itself. Conclusion : Allow placing external graphics and expose a minimal but sufficient set of embedded drawing operations.","title":"Background"},{"location":"background/#background","text":"Below are some observations that inspired the design of Pris.","title":"Background"},{"location":"background/#observations","text":"While a declarative source with a theme (such as html with css, or LaTeX) works great for long documents, it is somewhat inflexible for slides. Good slides need to be designed, and this is much more a manual process than typesetting large blocks of text. If you want to be able to change themes with a single click, then you need to shoehorn slides into a pretty limited format. Separating markup from content is not a good idea for creative slides: markup is an important part of the content. Conclusion : Don\u2019t try to separate semantics from markup. Specifying semantics is a non-goal. Offer full control over markup instead. To design graphics (which is what good slides should be), a graphical editor can be much nicer than a declarative format. Compare Inkscape with LaTeX and TikZ. However, a text-based declarative format has several advantages: it is nicer to work with in source control, and it can easily be scripted. Compare animating a hand-drawn graph in Google Slides with animating a TikZ drawing in LaTeX and Beamer. Manual animation often involves copying the entire thing, after which changing parts becomes difficult. It is possible to build a graphical editor for a text-based format, but these often produce messy output. Conclusion : A declarative text-based input format that is intended to be written by humans is preferred over an opaque format with a graphical editor. Supporting external graphics (svg logos, jpeg photographs, png graphics) is a must. For consistent graphics, having basic drawing capabilities embedded would be useful (like TikZ in LaTex). The possibility to leverage external tools is limited if consistency is a goal. (For instance, even if the same font is used in externally drawn graphics, the graphic must be scaled to make font sizes match.) Care must be taken to keep the scope narrow: TikZ is a huge project in itself. Conclusion : Allow placing external graphics and expose a minimal but sufficient set of embedded drawing operations.","title":"Observations"},{"location":"building/","text":"Building Pris is written in Rust and builds with Cargo, the build tool bundled with Rust. When system dependencies are installed, cargo build is sufficient. git clone https://github.com/ruuda/pris cd pris cargo build --release target/release/pris --help target/release/pris examples/lines.pris evince examples/lines.pdf If building does not succeed at first, some system dependencies might not be installed. See below. Linux To install system dependencies on Ubuntu: apt install libcairo2-dev libharfbuzz-dev librsvg2-dev To install system dependencies on Arch Linux: pacman -S --needed cairo harfbuzz librsvg fontconfig freetype2 Mac On Mac, system dependencies can be installed through Homebrew: brew install cairo harfbuzz librsvg fontconfig Windows On Windows, system dependencies can be installed inside an MSYS2 environment. More information will follow soon. For now, check out the windows branch for more information.","title":"Building"},{"location":"building/#building","text":"Pris is written in Rust and builds with Cargo, the build tool bundled with Rust. When system dependencies are installed, cargo build is sufficient. git clone https://github.com/ruuda/pris cd pris cargo build --release target/release/pris --help target/release/pris examples/lines.pris evince examples/lines.pdf If building does not succeed at first, some system dependencies might not be installed. See below.","title":"Building"},{"location":"building/#linux","text":"To install system dependencies on Ubuntu: apt install libcairo2-dev libharfbuzz-dev librsvg2-dev To install system dependencies on Arch Linux: pacman -S --needed cairo harfbuzz librsvg fontconfig freetype2","title":"Linux"},{"location":"building/#mac","text":"On Mac, system dependencies can be installed through Homebrew: brew install cairo harfbuzz librsvg fontconfig","title":"Mac"},{"location":"building/#windows","text":"On Windows, system dependencies can be installed inside an MSYS2 environment. More information will follow soon. For now, check out the windows branch for more information.","title":"Windows"},{"location":"getting-started/","text":"Getting started As there are currently no binaries for Pris, the first step is to build Pris from source, as explained in the building chapter. For now, the best way to get started is to take a look at the examples . This document will be extended in the future.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"As there are currently no binaries for Pris, the first step is to build Pris from source, as explained in the building chapter. For now, the best way to get started is to take a look at the examples . This document will be extended in the future.","title":"Getting started"},{"location":"language/","text":"The language This chapter characterizes the Pris domain specific language in various ways. It may help to determine where Pris is positioned relative to other languages. If you want to get your hands dirty, the examples may be a better way to get started. Paradigm Pris is purely functional , in the following sense: Pris has first-class functions: functions can be passed around as values. Functions in Pris are pure: they have no side effects. Values in Pris are immutable, there are no mutable objects. Pris is imperative , in the sense that blocks consist of statements that are executed sequentially. A statement is either assignment to a variable, a put statement that places a frame, or a return from a block. Although assignments mutate the bindings in the current scope, and put statements mutate the current frame, these mutations are only visible to the current block, and do not affect the surrounding scope. x = 1 y = { x = 2 return x } // At this point, x = 1 and y = 2. Pris is dynamically scoped , in the sense that the variables that are in scope when a function is evaluated, depend on the call site, not on the site where the function was defined. When used carelessly, this can make make programs intractable quickly. But when used with care, dynamic scoping is a powerful tool for a graphics language, reminiscent of the cascading properties of CSS . For example, we can write a title function that makes no particular choice of color, so the surrounding scope can control the color. title = function(text) { font_size = 0.2h text_align = \"center\" put t(title) at (0.5w, 0.5h) } { // This title will be red. color = #ff0000 put title(\"Slide 1\") } { // This title will be blue. color = #0000ff put title(\"Slide 2\") } Due to dynamic scoping, there are two ways to provide a value to a function: By setting a particular variable in the calling scope. By passing the value as a function argument. Variables are useful for values that do not change often, to avoid having to pass them all the time. For example, the t function uses the font_family and font_style from the surrounding scope, but accepts the text as argument. Type system Pris is strongly typed , in the sense that it reports a type error for nonsensical operations, rather than implicitly coercing values. Number types have units: a length is different from a dimensionless number. Pris is dynamically typed , in the sense that type errors in unreachable code do not cause compilation to fail. // Calling this function will trigger a type error, // but defining it does not. trigger_error = function() { return \"wrong\" + 0 } Dynamic typing is not a deep design choice, it is simply easier to implement. Pris may acquire static type checking in the future. Semantics Evaluation in Pris is strict . Function arguments are reduced to values before evaluating the function body, and the right-hand side of an assignment is evaluated fully before continuing to the next statement. Suffixes are resolved eagerly . Relative lengths are converted into absolute lengths as soon as they are evaluated, and the conversion depends on the meaning of the suffix at that time. Arithmetic with lenghts does not operate on symbolic suffixes. font_size = 0.1h x = 1em // At this point, x = 0.1h. font_size = 0.2h // At this point, x = 0.1h still. Syntax Pris is whitespace-insensitive . Whitespace separates tokens, but the amount, and the distinction between spaces and newlines, are irrelevant. Tabs and carriage returns are rejected by the parser. Pris does not have a statement separator . Rather, the grammar is constructed in such a way that statement boundaries are unambiguous. // You can put multiple statements on a line. // That doesn't mean it's a good idea though. x = 10 y = 12 put t(\"12\") z = 1 + 2 w = z","title":"The language"},{"location":"language/#the-language","text":"This chapter characterizes the Pris domain specific language in various ways. It may help to determine where Pris is positioned relative to other languages. If you want to get your hands dirty, the examples may be a better way to get started.","title":"The language"},{"location":"language/#paradigm","text":"Pris is purely functional , in the following sense: Pris has first-class functions: functions can be passed around as values. Functions in Pris are pure: they have no side effects. Values in Pris are immutable, there are no mutable objects. Pris is imperative , in the sense that blocks consist of statements that are executed sequentially. A statement is either assignment to a variable, a put statement that places a frame, or a return from a block. Although assignments mutate the bindings in the current scope, and put statements mutate the current frame, these mutations are only visible to the current block, and do not affect the surrounding scope. x = 1 y = { x = 2 return x } // At this point, x = 1 and y = 2. Pris is dynamically scoped , in the sense that the variables that are in scope when a function is evaluated, depend on the call site, not on the site where the function was defined. When used carelessly, this can make make programs intractable quickly. But when used with care, dynamic scoping is a powerful tool for a graphics language, reminiscent of the cascading properties of CSS . For example, we can write a title function that makes no particular choice of color, so the surrounding scope can control the color. title = function(text) { font_size = 0.2h text_align = \"center\" put t(title) at (0.5w, 0.5h) } { // This title will be red. color = #ff0000 put title(\"Slide 1\") } { // This title will be blue. color = #0000ff put title(\"Slide 2\") } Due to dynamic scoping, there are two ways to provide a value to a function: By setting a particular variable in the calling scope. By passing the value as a function argument. Variables are useful for values that do not change often, to avoid having to pass them all the time. For example, the t function uses the font_family and font_style from the surrounding scope, but accepts the text as argument.","title":"Paradigm"},{"location":"language/#type-system","text":"Pris is strongly typed , in the sense that it reports a type error for nonsensical operations, rather than implicitly coercing values. Number types have units: a length is different from a dimensionless number. Pris is dynamically typed , in the sense that type errors in unreachable code do not cause compilation to fail. // Calling this function will trigger a type error, // but defining it does not. trigger_error = function() { return \"wrong\" + 0 } Dynamic typing is not a deep design choice, it is simply easier to implement. Pris may acquire static type checking in the future.","title":"Type system"},{"location":"language/#semantics","text":"Evaluation in Pris is strict . Function arguments are reduced to values before evaluating the function body, and the right-hand side of an assignment is evaluated fully before continuing to the next statement. Suffixes are resolved eagerly . Relative lengths are converted into absolute lengths as soon as they are evaluated, and the conversion depends on the meaning of the suffix at that time. Arithmetic with lenghts does not operate on symbolic suffixes. font_size = 0.1h x = 1em // At this point, x = 0.1h. font_size = 0.2h // At this point, x = 0.1h still.","title":"Semantics"},{"location":"language/#syntax","text":"Pris is whitespace-insensitive . Whitespace separates tokens, but the amount, and the distinction between spaces and newlines, are irrelevant. Tabs and carriage returns are rejected by the parser. Pris does not have a statement separator . Rather, the grammar is constructed in such a way that statement boundaries are unambiguous. // You can put multiple statements on a line. // That doesn't mean it's a good idea though. x = 10 y = 12 put t(\"12\") z = 1 + 2 w = z","title":"Syntax"},{"location":"name/","text":"Name Pris is named after Pris Stratton, the Blade Runner character in turn based on the character from Dick\u2019s 1968 novel Do Androids Dream of Electric Sheep? . The fact that \u2018Pris\u2019 sounds like a prefix of \u2018presentation\u2019 might or might not have something to do with it. The fact that pris is a nice and short name for a command-line application is entirely coincidental.","title":"Name"},{"location":"name/#name","text":"Pris is named after Pris Stratton, the Blade Runner character in turn based on the character from Dick\u2019s 1968 novel Do Androids Dream of Electric Sheep? . The fact that \u2018Pris\u2019 sounds like a prefix of \u2018presentation\u2019 might or might not have something to do with it. The fact that pris is a nice and short name for a command-line application is entirely coincidental.","title":"Name"},{"location":"parser/","text":"Parser The current parser used in Pris is a hand-written parser. See src/parser.rs for more information. Previously, a parser generated by lalrpop was used. This parser was replaced mainly because of the long compile times caused by lalrpop and its many dependencies. The opportunity for better error messages and reduced binary size are other advantages. Build time Build times on Rust 1.19.0-beta.1, median and standard deviation of 3 clean builds, excluding crate download time: Version Mode Build time (s) b504558 debug 83.2 \u00b1 2.2 4bb1e60 debug 16.2 \u00b1 0.5 b504558 release 225.9 \u00b1 3.9 4bb1e60 release 36.8 \u00b1 1.9 b504558 is the lalrpop -based revision, 4bb1e60 uses the new parser. Binary size The binary size for a release build, after stripping: Version Binary size (KiB) b504558 1644.0 4bb1e60 1380.0 That is almost a 20% reduction in binary size.","title":"Parser"},{"location":"parser/#parser","text":"The current parser used in Pris is a hand-written parser. See src/parser.rs for more information. Previously, a parser generated by lalrpop was used. This parser was replaced mainly because of the long compile times caused by lalrpop and its many dependencies. The opportunity for better error messages and reduced binary size are other advantages.","title":"Parser"},{"location":"parser/#build-time","text":"Build times on Rust 1.19.0-beta.1, median and standard deviation of 3 clean builds, excluding crate download time: Version Mode Build time (s) b504558 debug 83.2 \u00b1 2.2 4bb1e60 debug 16.2 \u00b1 0.5 b504558 release 225.9 \u00b1 3.9 4bb1e60 release 36.8 \u00b1 1.9 b504558 is the lalrpop -based revision, 4bb1e60 uses the new parser.","title":"Build time"},{"location":"parser/#binary-size","text":"The binary size for a release build, after stripping: Version Binary size (KiB) b504558 1644.0 4bb1e60 1380.0 That is almost a 20% reduction in binary size.","title":"Binary size"},{"location":"reference/at/","text":"at at(frame: frame, offset: coord) -> frame Move a frame by the given offset. This is used to position elements on the canvas, or relative to a scope, and the function is usually called with infix notation. Example: // Place an image in the top-left corner of the canvas. put image(\"logo.png\") at (1em, 1em)","title":"at"},{"location":"reference/at/#at","text":"at(frame: frame, offset: coord) -> frame Move a frame by the given offset. This is used to position elements on the canvas, or relative to a scope, and the function is usually called with infix notation. Example: // Place an image in the top-left corner of the canvas. put image(\"logo.png\") at (1em, 1em)","title":"at"},{"location":"reference/canvas_size/","text":"canvas_size canvas_size: vec2 A variable that sets the aspect ratio of the canvas. Must be assigned in the global scope. The last assignment to this variable determines the canvas size for all slides in the document, it is currently not possible to have slides of different sizes in a single document. Note that after changing the canvas size, variables that had been assigned a value relative to the canvas size, continue to hold their absolute value, which may no longer make sense for the new canvas size. For example: canvas_size = (1, 1) half = 0.5w canvas_size = (2, 2) // \"half\" is now effectively 0.25w, no longer half the canvas width.","title":"canvas_size"},{"location":"reference/canvas_size/#canvas_size","text":"canvas_size: vec2 A variable that sets the aspect ratio of the canvas. Must be assigned in the global scope. The last assignment to this variable determines the canvas size for all slides in the document, it is currently not possible to have slides of different sizes in a single document. Note that after changing the canvas size, variables that had been assigned a value relative to the canvas size, continue to hold their absolute value, which may no longer make sense for the new canvas size. For example: canvas_size = (1, 1) half = 0.5w canvas_size = (2, 2) // \"half\" is now effectively 0.25w, no longer half the canvas width.","title":"canvas_size"},{"location":"reference/fill_circle/","text":"fill_circle fill_circle(radius: len) -> frame Draw a solid circle. The origin of the returned circle is in its center. The fill color is taken from the color variable.","title":"fill_circle"},{"location":"reference/fill_circle/#fill_circle","text":"fill_circle(radius: len) -> frame Draw a solid circle. The origin of the returned circle is in its center. The fill color is taken from the color variable.","title":"fill_circle"},{"location":"reference/fill_rectangle/","text":"fill_rectangle fill_rectangle(size: coord) -> frame Draw a solid rectangle. The origin of the returned rectangle is at its top-left corner. The fill color is taken from the color variable.","title":"fill_rectangle"},{"location":"reference/fill_rectangle/#fill_rectangle","text":"fill_rectangle(size: coord) -> frame Draw a solid rectangle. The origin of the returned rectangle is at its top-left corner. The fill color is taken from the color variable.","title":"fill_rectangle"},{"location":"reference/fit/","text":"fit fit(frame: frame, size: coord) -> frame Scale a frame to fit inside a rectangle of the given size, respecting aspect ratio.","title":"fit"},{"location":"reference/fit/#fit","text":"fit(frame: frame, size: coord) -> frame Scale a frame to fit inside a rectangle of the given size, respecting aspect ratio.","title":"fit"},{"location":"reference/glyph/","text":"glyph glyph(glyph_index: num) -> frame Render a single glyph, selected by glyph index, which must be a positive integer. Font and color are controlled in the same way as with t .","title":"glyph"},{"location":"reference/glyph/#glyph","text":"glyph(glyph_index: num) -> frame Render a single glyph, selected by glyph index, which must be a positive integer. Font and color are controlled in the same way as with t .","title":"glyph"},{"location":"reference/hyperlink/","text":"hyperlink hyperlink(uri: str, size: coord) -> frame Create a rectangular area of size size that opens the given URI when clicked. The frame itself has no visual artifacts, it can be added over text or over a rectangle, for example. The origin of the clickable area is in the top-left corner.","title":"hyperlink"},{"location":"reference/hyperlink/#hyperlink","text":"hyperlink(uri: str, size: coord) -> frame Create a rectangular area of size size that opens the given URI when clicked. The frame itself has no visual artifacts, it can be added over text or over a rectangle, for example. The origin of the clickable area is in the top-left corner.","title":"hyperlink"},{"location":"reference/image/","text":"image image(fname: str) -> frame Load a PNG or SVG graphic from the file with path fname . Currently the path is relative to the working directory, but it should be made relative to the source file. The origin of the returned frame is in the top-left corner. The size of the image relative to the canvas depends on the input image, and is often not meaningful. To resize the image, use the fit function.","title":"image"},{"location":"reference/image/#image","text":"image(fname: str) -> frame Load a PNG or SVG graphic from the file with path fname . Currently the path is relative to the working directory, but it should be made relative to the source file. The origin of the returned frame is in the top-left corner. The size of the image relative to the canvas depends on the input image, and is often not meaningful. To resize the image, use the fit function.","title":"image"},{"location":"reference/line/","text":"line line(pos: coord) -> frame Draw a line from the origin to the given position. The origin of the returned line is at the first vertex. The line color is taken from the color variable, the width from the line_width variable.","title":"line"},{"location":"reference/line/#line","text":"line(pos: coord) -> frame Draw a line from the origin to the given position. The origin of the returned line is at the first vertex. The line color is taken from the color variable, the width from the line_width variable.","title":"line"},{"location":"reference/str/","text":"str str(x: num) -> str Turn a number into a string.","title":"str"},{"location":"reference/str/#str","text":"str(x: num) -> str Turn a number into a string.","title":"str"},{"location":"reference/t/","text":"t t(text: str) -> frame Render a piece of text. This function will likely be renamed to text in the future, when string prefixes are supported. The font can be selected with the font_family and font_style variables. Alignment can be controlled with the text_align variable, which must be one of \"left\" , \"center\" , or \"right\" . Line height is controlled by the line_height variable. The origin of the returned frame is on the baseline of the first line. The text color is taken from the color variable.","title":"t"},{"location":"reference/t/#t","text":"t(text: str) -> frame Render a piece of text. This function will likely be renamed to text in the future, when string prefixes are supported. The font can be selected with the font_family and font_style variables. Alignment can be controlled with the text_align variable, which must be one of \"left\" , \"center\" , or \"right\" . Line height is controlled by the line_height variable. The origin of the returned frame is on the baseline of the first line. The text color is taken from the color variable.","title":"t"},{"location":"README.theme/","text":"Kilsbergen A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more. Demos Tako documentation Pris documentation Features Responsive design Zero javascript License Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"Kilsbergen"},{"location":"README.theme/#kilsbergen","text":"A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more.","title":"Kilsbergen"},{"location":"README.theme/#demos","text":"Tako documentation Pris documentation","title":"Demos"},{"location":"README.theme/#features","text":"Responsive design Zero javascript","title":"Features"},{"location":"README.theme/#license","text":"Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"License"}]}