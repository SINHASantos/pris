// Pris -- A language for designing slides
// Copyright 2017 Ruud van Asseldonk

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 3. A copy
// of the License is available in the root of the repository.

//! This module contains building blocks for the parser. The actual parser is
//! generated by Lalrpop, and can be found in the `syntax` module.


//! This module contains a custom lexer that feeds tokens to Lalrpop.
//!
//! A custom lexer is required because the lexer generated by Lalrpop cannot
//! deal with comments that span to the end of the line. It also enables support
//! for non-greedy triple quoted strings, which cannot be expressed in as regex
//! without support for non-greedy matching.

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum PreToken {
    Normal,
    Comment,
    String,
    RawString,
}

/// Do a very rough lexing pass to separate comments and strings from the rest.
///
/// Returned tuples are (start_index, token, past_end_index).
fn prelex(input: &str) -> Vec<(usize, PreToken, usize)> {
    #[derive(Copy, Clone)]
    enum State {
        Normal,
        NormalAfterSlash,
        NormalAfterDash1,
        NormalAfterDash2,
        InComment,
        InString,
        InStringAfterBackslash,
        InRawString,
        InRawStringAfterDash1,
        InRawStringAfterDash2,
    }

    let mut tokens = Vec::new();
    let mut state = State::Normal;
    let mut start = 0;

    // The input string is encoded as UTF-8, so we can iterate over the bytes,
    // because the only characters interesting to the parser are ASCII
    // characters, and non-ASCII characters are never encoded as an ASCII one.
    for (i, ch) in input.bytes().enumerate() {
        loop {
            match (ch, state) {
                // Two slashes to start a comment.
                (b'/', State::Normal) => {
                    state = State::NormalAfterSlash;
                }
                (b'/', State::NormalAfterSlash) => {
                    if start != i - 1 {
                        // Push the preceding normal token if it was non-empty.
                        tokens.push((start, PreToken::Normal, i - 1));
                    }
                    start = i - 1;
                    state = State::InComment;
                }
                (_, State::NormalAfterSlash) => {
                    state = State::Normal;
                    continue;
                }
                (b'\n', State::InComment) => {
                    tokens.push((start, PreToken::Comment, i));
                    start = i;
                    state = State::Normal;
                }
                (_, State::InComment) => {
                    // Nothing interesting until the newline.
                }
                // Triple dashes to start a raw string.
                (b'-', State::Normal) => {
                    state = State::NormalAfterDash1;
                }
                (b'-', State::NormalAfterDash1) => {
                    state = State::NormalAfterDash2;
                }
                (b'-', State::NormalAfterDash2) => {
                    if start != i - 2 {
                        // Push the preceding normal token if it was non-empty.
                        tokens.push((start, PreToken::Normal, i - 2));
                    }
                    start = i - 2;
                    state = State::InRawString;
                }
                (_, State::NormalAfterDash1) => {
                    state = State::Normal;
                    continue;
                }
                (_, State::NormalAfterDash2) => {
                    state = State::Normal;
                    continue;
                }
                (b'-', State::InRawString) => {
                    state = State::InRawStringAfterDash1;
                }
                (b'-', State::InRawStringAfterDash1) => {
                    state = State::InRawStringAfterDash2;
                }
                (b'-', State::InRawStringAfterDash2) => {
                    tokens.push((start, PreToken::RawString, i + 1));
                    start = i + 1;
                    state = State::Normal;
                }
                (_, State::InRawStringAfterDash1) => {
                    state = State::InRawString;
                }
                (_, State::InRawStringAfterDash2) => {
                    state = State::InRawString;
                }
                (_, State::InRawString) => {
                    // Nothing interesting until a dash.
                }
                // A double quote starts a regular string.
                (b'"', State::Normal) => {
                    if start != i {
                        // Push the preceding normal token if it was non-empty.
                        tokens.push((start, PreToken::Normal, i));
                    }
                    start = i;
                    state = State::InString;
                }
                (b'\\', State::InString) => {
                    state = State::InStringAfterBackslash;
                }
                (_, State::InStringAfterBackslash) => {
                    state = State::InString;
                }
                (b'"', State::InString) => {
                    tokens.push((start, PreToken::String, i + 1));
                    start = i + 1;
                    state = State::Normal;
                }
                (_, State::InString) => {
                    // Continue inside the string.
                }
                (_, State::Normal) => {
                    // Continue lexing outside of a string and comment.
                }
            }
            break;
        }
    }

    let final_token = match state {
        State::Normal => PreToken::Normal,
        State::NormalAfterSlash => PreToken::Normal,
        State::NormalAfterDash1 => PreToken::Normal,
        State::NormalAfterDash2 => PreToken::Normal,
        State::InComment => PreToken::Comment,
        State::InString => PreToken::String,
        State::InStringAfterBackslash => PreToken::String,
        State::InRawString => PreToken::RawString,
        State::InRawStringAfterDash1 => PreToken::RawString,
        State::InRawStringAfterDash2 => PreToken::RawString,
    };
    if start != input.len() {
        tokens.push((start, final_token, input.len()));
    }

    tokens
}

#[test]
fn prelex_handles_a_simple_input() {
    let input = "foo bar";
    let tokens = prelex(input);
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens[0], (0, PreToken::Normal, 7));
}

#[test]
fn prelex_handles_a_string_literal() {
    let input = r#"foo "bar""#;
    let tokens = prelex(input);
    assert_eq!(tokens.len(), 2);
    assert_eq!(tokens[0], (0, PreToken::Normal, 4));
    assert_eq!(tokens[1], (4, PreToken::String, 9));
}

#[test]
fn prelex_handles_a_string_literal_with_escaped_quote() {
    let input = r#""bar\"baz""#;
    let tokens = prelex(input);
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens[0], (0, PreToken::String, 10));
}

#[test]
fn prelex_handles_a_comment() {
    let input = "foo\n// This is comment\nbar";
    let tokens = prelex(input);
    assert_eq!(tokens.len(), 3);
    assert_eq!(tokens[0], (0, PreToken::Normal, 4));
    assert_eq!(tokens[1], (4, PreToken::Comment, 22));
    assert_eq!(tokens[2], (22, PreToken::Normal, 26));
}

#[test]
fn prelex_handles_a_raw_string() {
    let input = "foo---bar---baz";
    let tokens = prelex(input);
    assert_eq!(tokens.len(), 3);
    assert_eq!(tokens[0], (0, PreToken::Normal, 3));
    assert_eq!(tokens[1], (3, PreToken::RawString, 12));
    assert_eq!(tokens[2], (12, PreToken::Normal, 15));
}
